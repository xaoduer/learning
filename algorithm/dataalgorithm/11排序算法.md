# 11.排序
![sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/11.sort.jpg)

## 排序算法执行效率
1.最好，最坏，平均情况时间复杂度  
2.时间复杂度的系数、常数、低阶  
3.比较次数和交换（或移动）次数  

## 排序算法的内存消耗
1.空间复杂度  
2.原地排序 —— 空间复杂度是O(1)  

## 排序算法的稳定性 —— 排序后相等元素之间原有的先后顺序保持不变

## 冒泡排序
![bubble sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/11.bubble-sort.jpg)
```
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```
原地排序、稳定，O(n2)

## 插入排序
![insertion sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/11.insertion-sort.jpg)
```
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```
原地排序、稳定，O(n2)  

## 选择排序
原地排序、不稳定，O(n2)
![section sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/11.selection-sort.jpg)
# 12.归并和快速排序
## 归并
![combine-sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/12.combine-sort.jpg)
```
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```
<p>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p>

```
// 归并排序算法, A 是数组，n 表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取 p 到 r 之间的中间位置 q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
```
<p>如图所示，我们申请一个临时数组 tmp，大小与 A[p…r] 相同。我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。</p>
<p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r] 中。</p>
![combine-array](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/12.combine-array.jpg)

merge伪代码：  
```
merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++ 等于 i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组 tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将 tmp 中的数组拷贝回 A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
```
### 稳定，时间O(nlogn)，空间O(nlogn)
## 快速
<p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>
![quick-sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/12.quick-sort.jpg)

```
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

终止条件：
p >= r
```

```
// 快速排序，A 是数组，n 表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r 为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}
```
原地分区：  
```
partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i

```

![compare](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/12.compare.jpg)

# 13.线性排序 O(n)
## 桶排序
适合外部排序,根据年龄给100万用户排序    
![bucket sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/13.bucket-sort.jpg)
## 计数排序
按高考分数排序  
![counting sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/13.counting-sort.jpg)

```
// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入 c 中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组 r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给 a 数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```
<p><strong>计数排序只能用在数据范围不大的场景<strong><strong>中</strong></strong>，如果数据范围 k 比要排序的数据 n 大很多，就<strong><strong>不</strong></strong>适合用<strong><strong>计数</strong></strong>排序了。而且，<strong><strong>计数</strong></strong>排序只能<strong><strong>给</strong></strong>非负整数<strong><strong>排序</strong></strong>，如果要排序的数据是其他类型的，要<strong><strong>将</strong></strong>其在不改变相对大小的情况下，转化为非负整数。</strong></p>
## 基数排序
10w个手机号码排序  
![radix sort](https://github.com/xaoduer/learning/blob/master/algorithm/dataalgorithm/imgs/13.radix.jpg)
<strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</strong>