# 05.物理层 MAC层
## 第一层：物理层
电脑直连：1-3、2-6交叉接法  
Hub：广播模式  
## 第二层：数据链路层 MAC —— Medium Access Control
1.包发给谁的？谁应该接收？  
2.大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？  
3.如果发送的时候出现错误，怎么办？  

### 解决方式：
方式一：多个车道 —— 信道划分  
方式二：限号出行 —— 轮流协议    
方式三：有事儿先出门，发现堵就回去，错过高峰再出行 —— 随机接入协议  

MAC层解决多路访问的堵车问题  
ARP —— 广播寻找目标MAC地址  
交换机有MAC地址学习能力，学完了就知道谁在哪儿，不用广播了

*之前有无盘工作站，即没有硬盘的机器，无法持久化ip地址到本地，但有网卡，所以可以用RARP协议来获取IP地址。RARP可以用于局域网管理员想指定机器IP（与机器绑定，不可变），又不想每台机器去设置静态IP的情况，可以在RARP服务器上配置MAC和IP对应的ARP表，不过获取每台机器的MAC地址，好像也挺麻烦的。这个协议现在应该用得不多了吧，都用BOOTP或者DHCP了。*

# 06.交换机与VLAN —— 虚拟局域网
环路问题  
![recircle-problem]()

解决环路问题：  
## STP —— Spanning Tree Protocol 最小生成树  
* Root Bridge 根交换机
* Designated Bridges 指定交换机
* Bridge Protocol Data Units  网桥协议数据单元
* Priority Vector 优先级向量

VLAN:  
Trunk口：交换机之间互联  
![VLAN]()  

当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。  
交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。  

# 08.网络层
MAC地址是一个局域网内才有效的地址，因此，MAC地址只要过网关，就必定会改变，因为已经换了局域网  
不改变IP地址的网关 —— 转发网关  
改变IP的网关 —— NAT网关 NetWork Address Translation 局域网转互联网     

如果离开本局域网，就需要经过网关，网关是路由器的一个网口  
路由器是一个三层设备，里面有如何寻找下一跳的规则  
经过路由器之后MAC头要变，如果IP不变，转发网关。如果IP变，NAT网关  

# 09.路由表
* 目的网络：这个包想去哪儿？
* 出口设备：将包从哪个口扔出去？
* 下一跳网关： 下一个路由器的地址。 
## 如何配置路由？ 
route / ip route   
ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0 ,就说明要去10.176.48.0/20这个目标网络，要从eth0端口出去，经过10.173.32.1  

```
ip rule add from 192.168.1.0/24 table 10 
ip rule add from 192.168.2.0/24 table 20
ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
```
## 动态路由算法
最短路径算法：Bellman-ford Dijkstra  
1.距离矢量路由算法 —— distance vector routing  基于Bellman-Ford  
<p>这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。</p>
<p>由此可以看出，每个路由器都是知道全局信息的。那这个信息如何更新呢？每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。</p>
<p>每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。</p>
问题：如果一个路由器挂了？  
2.链路状态路由算法 —— link state routing    
<p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径。</p>
<p>不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和 CPU 利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。</p>

### 基于链路状态路由算法的OSPF
OSPF Open Shortest Path First 开放式最短路径优先。也称为内部网关协议 Interior Gateway Protocol 简称IGP  

### 基于距离矢量路由算法的BGP
外网路由协议 Border Gateway Protocol 简称BGP  
在网络世界，一个个国家成为自治系统AS（Autonomous System）  
* <p>Stub AS：对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。</p>
* <p>Multihomed AS：可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。</p>
* <p>Transit AS：有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。</p>
每个自治系统都有边界路由器，通过它和外面的世界建立联系  
<p><strong>BGP 又分为两类，eBGP 和 iBGP。</strong>自治系统间，边界路由器之间使用 eBGP 广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。</p>

总结：  
* 路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略  
* 动态路由主流算法有两种，基于两种算法产生两种协议，BGP和OSPF  

```
一、求最短距离的两个常见算法：
1.1 Bellman-Ford：是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。
1.2 Dijkstra：是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
二、路由器的路由算法：
2.1 距离矢量路由算法：每个路由器维护一张路由表，即一个矢量，它以网络中的每个路由器为索引，表中列出了当前已知的路由器到每个目标路由器的最佳距离，以及所使用的线路。通过在邻居之间相互交换信息，路由器不断地更新他们的内部路由表。（该算法基于Bellman-Ford）
2.2 链路状态路由算法：是要求网络中所有参与链路状态路由协议的路由器都掌握网络的全部拓扑结构信息，并记录在路由数据库中。链路状态算法中路由数据库实质上是一个网络结构的拓扑图，该拓扑图由一个节点的集合和一个边的集合构成。在网络拓扑图中，结点代表网络中路由器，边代表路由器之间的物理链路。在网络拓扑结构图中，每一条链路上可以附加不同的属性，例如链路的状态、距离或费用等。如果每一个路由器所保存的网络拓扑结构图都是一致的，那么个路由器生成的路由表也是最佳的，不存在错误路由或循环路由。（该算法基于Dijkstra）。
三：基于两个路由算法而衍生出来的两个路由协议：
3.1基于距离矢量路由算法的BGP协议：???
3.2基于链路状态路由算法的OSPF协议：???
小结：
1.距离矢量路由算法存在环回路由，慢收敛，无穷计算，扩展性差等，存在的问题：环回路由，慢收敛，无穷计算，扩展性差，仅适用于小网络场景。
2.链路状态路由算法：链路状态算法具有更快的收敛速度,具有更好的功能扩展能力.还提供了更好的在规模上的可升级性，缺点：每个路由器需要有较大的存储空间，用以存储所收到的每一个节点的链路状态分组；计算工作量大，每次都必须计算最短路径。
```
  







